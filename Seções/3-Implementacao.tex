% =========================================================  
% Capítulo 3 — Implementação e Experimentos  
% =========================================================  

\section{Introdução}  
Este capítulo apresenta a implementação prática dos métodos de busca discutidos nos Capítulos~1 e~2, aplicada ao problema do 8-puzzle. O objetivo é demonstrar como os conceitos teóricos — modelagem do espaço de estados, operadores, heurísticas, algoritmos UCS e $A^*$ — são traduzidos em código e, posteriormente, avaliar seu desempenho em instâncias reais do problema.  

\section{Modelagem Computacional do 8-puzzle}  
Baseando-se na modelagem formal apresentada na Seção~2.1, o estado do tabuleiro é representado por uma tupla de nove inteiros, permitindo hashing eficiente e comparação rápida entre estados. Foram desenvolvidas funções utilitárias para conversão entre representações matriciais e lineares, além de um método para exibição do tabuleiro no terminal.  

\begin{minted}[frame=lines, fontsize=\footnotesize, linenos]{python}  
LINHAS, COLS = 3, 3  
TABULEIRO_OBJETIVO = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # 9 representa o espaço em branco  

def tabuleiro_para_tupla(tabuleiro):  
    """Converte o tabuleiro (lista de listas) em uma tupla para facilitar comparação e hashing."""  
    return tuple(tabuleiro[i][j] for i in range(LINHAS) for j in range(COLS))  

def tupla_para_tabuleiro(t):  
    """Converte uma tupla em formato tabuleiro (lista de listas)."""  
    return [list(t[i*COLS:(i+1)*COLS]) for i in range(LINHAS)]  

def desenhar_tabuleiro(tabuleiro):  
    """Imprime o tabuleiro de forma legível."""  
    for linha in tabuleiro:  
        print(linha)  
\end{minted}  

\subsection{Métodos Principais e Relação com o Algoritmo A*}  
Para garantir transparência e facilitar o entendimento do fluxo do algoritmo, listam-se abaixo os métodos centrais da implementação e suas respectivas funções no contexto do $A^*$:  

\begin{itemize}  
    \item \texttt{expandir()} (classe \texttt{No}): Responsável pela geração dos filhos de um nó, ou seja, por criar os estados sucessores a partir de um estado atual. No $A^*$, cada nó expandido aciona essa função para descobrir os próximos estados possíveis e calcular o custo de transição.  
    \item \texttt{distancia\_manhattan()} e \texttt{pecas\_erradas()}: Funções de heurística informada. A primeira calcula a soma das distâncias de Manhattan de cada peça à sua posição correta (admissível e consistente); a segunda conta o número de peças fora do lugar (admissível, porém menos informativa). No $A^*$, essas funções estimam o custo restante até o objetivo e influenciam a ordem de expansão dos nós na fronteira.  
    \item \texttt{busca()}: Função principal que executa UCS ou $A^*$, controlando a fronteira (fila de prioridade), aplicando a heurística selecionada e gerenciando a expansão dos nós, bem como o controle de estados repetidos.  
    \item \texttt{reconstruir\_caminho()}: Após encontrar o estado objetivo, esta função recupera o caminho percorrido desde o nó inicial até a solução, permitindo a análise do desempenho e da sequência de movimentos.  
\end{itemize}  

O fluxo típico do $A^*$ na implementação segue:  
\begin{enumerate}  
    \item Inicialização da fronteira com o nó inicial;  
    \item Expansão dos nós usando \texttt{expandir()}, cálculo dos custos e da heurística;  
    \item Inserção dos filhos na fronteira ordenada pela função de avaliação $f(n) = g(n) + h(n)$;  
    \item Controle de estados repetidos para evitar loops;  
    \item Ao alcançar o objetivo, reconstrução do caminho com \texttt{reconstruir\_caminho()}.  
\end{enumerate}  
Cada método está diretamente ligado aos componentes teóricos do $A^*$ conforme a literatura.

\section{Verificação de Solubilidade}  
Conforme discutido no Capítulo~2, nem todas as configurações do 8-puzzle são solucionáveis. A função abaixo implementa a verificação baseada na contagem de inversões:  

\begin{minted}[frame=lines, fontsize=\footnotesize, linenos]{python}  
def contagem_inversoes(tabuleiro):  
    """Conta o número de inversões para verificar se o tabuleiro é solucionável."""  
    flat = [x for row in tabuleiro for x in row if x != 9]  
    inv = 0  
    for i in range(len(flat)):  
        for j in range(i+1, len(flat)):  
            if flat[i] > flat[j]:  
                inv += 1  
    return inv  

def eh_soluvel(tabuleiro):  
    """Retorna True se o tabuleiro é solucionável."""  
    return contagem_inversoes(tabuleiro) % 2 == 0  
\end{minted}  

\section{Geração de Instâncias Aleatórias Solucionáveis}  
A geração de instâncias solucionáveis parte do estado objetivo, realizando movimentos aleatórios válidos do espaço vazio:  

\begin{minted}[frame=lines, fontsize=\footnotesize, linenos]{python}  
import random  

def tabuleiro_aleatorio_soluvel(movimentos_embaralhar=40, seed=None):  
    """Gera um tabuleiro aleatório solucionável a partir do objetivo."""  
    if seed is not None:  
        random.seed(seed)  
    tabuleiro = [linha[:] for linha in TABULEIRO_OBJETIVO]  
    t = tabuleiro_para_tupla(tabuleiro)  

    def pos_branco(t):  
        idx = t.index(9)  
        return divmod(idx, COLS)  

    for _ in range(movimentos_embaralhar):  
        i, j = pos_branco(t)  
        movimentos = []  
        if i > 0: movimentos.append((-1, 0))  
        if i < LINHAS-1: movimentos.append((1, 0))  
        if j > 0: movimentos.append((0, -1))  
        if j < COLS-1: movimentos.append((0, 1))  
        di, dj = random.choice(movimentos)  
        ni, nj = i + di, j + dj  
        lst = list(t)  
        idx1, idx2 = i*COLS + j, ni*COLS + nj  
        lst[idx1], lst[idx2] = lst[idx2], lst[idx1]  
        t = tuple(lst)  
    return tupla_para_tabuleiro(t)  
\end{minted}  

\section{Estruturas de Dados e Expansão de Nós}  
Cada nó do espaço de estados é representado por uma classe, contendo o estado do tabuleiro, referência ao nó pai e o custo acumulado. O método \texttt{expandir} gera todos os estados filhos possíveis:  

\begin{minted}[frame=lines, fontsize=\footnotesize, linenos]{python}  
from dataclasses import dataclass  

@dataclass  
class No:  
    tabuleiro: tuple  
    pai: object = None  
    custo: int = 0  

    def pos_branco(self):  
        idx = self.tabuleiro.index(9)  
        return divmod(idx, COLS)  

    def expandir(self):  
        i, j = self.pos_branco()  
        movimentos = [(-1,0),(1,0),(0,-1),(0,1)]  
        filhos = []  
        for di, dj in movimentos:  
            ni, nj = i + di, j + dj  
            if 0 <= ni < LINHAS and 0 <= nj < COLS:  
                nova_lista = list(self.tabuleiro)  
                idx1 = i*COLS + j  
                idx2 = ni*COLS + nj  
                nova_lista[idx1], nova_lista[idx2] = nova_lista[idx2], nova_lista[idx1]  
                filhos.append(No(tuple(nova_lista), pai=self, custo=self.custo + 1))  
        return filhos  
\end{minted}  

\section{Implementação das Heurísticas}  
As heurísticas admissíveis utilizadas são:  

\begin{minted}[frame=lines, fontsize=\footnotesize, linenos]{python}  
def objetivo_tupla():  
    return tabuleiro_para_tupla(TABULEIRO_OBJETIVO)  

def distancia_manhattan(t):  
    """Heurística admissível clássica."""  
    dist = 0  
    for val in t:  
        if val == 9:  
            continue  
        idx = t.index(val)  
        i, j = divmod(idx, COLS)  
        gi, gj = divmod(val-1, COLS)  
        dist += abs(i-gi) + abs(j-gj)  
    return dist  

def pecas_erradas(t):  
    """Heurística admissível simples: número de peças fora do lugar."""  
    g = objetivo_tupla()  
    return sum(1 for i in range(len(t)) if t[i] != 9 and t[i] != g[i])  
\end{minted}  

\section{Gerenciamento da Fronteira}  
No contexto dos algoritmos de busca UCS e $A^*$, a \textbf{fronteira} é o conjunto de nós ainda não expandidos, candidatos a serem explorados nas próximas etapas. O gerenciamento eficiente da fronteira é essencial para garantir que sempre seja selecionado o nó mais promissor em termos de custo total estimado.  

\subsection{Estrutura de Dados Utilizada}  
A implementação faz uso da estrutura \texttt{heapq} do Python, que representa uma fila de prioridade baseada em min-heap. Essa estrutura permite inserir e remover elementos de forma eficiente, garantindo que o nó com menor valor de prioridade ($f(n) = g(n) + h(n)$) seja expandido primeiro.  

\subsection{Controle de Dominância e Estados Repetidos}  
Para evitar a expansão redundante de estados e garantir que o caminho ótimo seja preservado, o algoritmo realiza uma verificação antes de adicionar um novo nó à fronteira. Só são inseridos os estados que nunca foram gerados anteriormente ou aqueles cujo custo atual é melhor (menor) que o custo já registrado para o mesmo estado. Esse controle é feito através do dicionário \texttt{custo\_ate}, que armazena o menor custo já encontrado para cada configuração do tabuleiro.  

O trecho relevante do código é apresentado a seguir:  

\begin{minted}[frame=lines, fontsize=\footnotesize, linenos]{python}  
for filho in atual.expandir():  
    g = filho.custo  
    # Só adiciona à fronteira se o estado for novo ou se o custo for melhor  
    if (filho.tabuleiro not in custo_ate) or (g < custo_ate[filho.tabuleiro]):  
        custo_ate[filho.tabuleiro] = g  
        f = g + hfun(filho.tabuleiro)  # Prioridade: custo real + heurística  
        heapq.heappush(fronteira, (f, contador, filho))  
        contador += 1  
\end{minted}  

\subsection{Funcionamento no Algoritmo}  
\begin{itemize}  
    \item O dicionário \texttt{custo\_ate} guarda o menor custo já encontrado para cada estado do tabuleiro.  
    \item Antes de inserir um novo nó na fronteira (\texttt{heapq.heappush}), verifica-se se o estado é inédito ou se há um caminho de menor custo para alcançá-lo.  
    \item A prioridade na fila é dada pelo valor de $f(n) = g(n) + h(n)$, sendo $g(n)$ o custo real acumulado e $h(n)$ o valor da heurística.  
    \item O campo \texttt{contador} serve para desempatar nós com mesmo valor de prioridade, evitando ambiguidades na ordenação.  
\end{itemize}  

Esta abordagem garante que a busca se mantenha ótima e eficiente, evitando ciclos e expansões desnecessárias, conforme discutido em Russell e Norvig (2010). O uso de \texttt{heapq} como fila de prioridade min-heap é fundamental para o desempenho dos algoritmos de busca informada, permitindo acesso rápido ao nó mais promissor a cada etapa.  

\section{Algoritmos de Busca}  
A seguir, apresenta-se a função principal que implementa tanto UCS quanto $A^*$, conforme o parâmetro de entrada:  

\begin{minted}[frame=lines, fontsize=\footnotesize, linenos]{python}  
import heapq  

def busca(tabuleiro_inicial, algoritmo="ucs", heuristica="manhattan", limite_expansoes=None):  
    """Executa UCS ou A* dependendo dos parâmetros."""  
    t_inicial = tabuleiro_para_tupla(tabuleiro_inicial)  
    t_objetivo = objetivo_tupla()  
    if algoritmo not in ("ucs", "astar"):  
        raise ValueError("algoritmo deve ser 'ucs' ou 'astar'")  
    if algoritmo == "astar":  
        if heuristica == "manhattan":  
            hfun = distancia_manhattan  
        elif heuristica == "pecas_erradas":  
            hfun = pecas_erradas  
        else:  
            raise ValueError("heuristica deve ser 'manhattan' ou 'pecas_erradas'")  
    else:  
        hfun = lambda _: 0  

    fronteira = []  
    contador = 0  
    no_inicial = No(t_inicial, pai=None, custo=0)  
    heapq.heappush(fronteira, (hfun(t_inicial), contador, no_inicial))  
    contador += 1  
    custo_ate = {t_inicial: 0}  
    fechados = {}  
    expandidos = 0  

    while fronteira:  
        _, _, atual = heapq.heappop(fronteira)  
        if atual.tabuleiro == t_objetivo:  
            caminho = reconstruir_caminho(atual)  
            return {  
                "encontrado": True,  
                "movimentos": len(caminho)-1,  
                "custo": atual.custo,  
                "caminho": caminho,  
                "tamanho_fechados": len(fechados),  
                "tamanho_fronteira": len(fronteira),  
                "expandidos": expandidos,  
                "algoritmo": algoritmo,  
                "heuristica": heuristica if algoritmo == "astar" else None  
            }  
        if atual.tabuleiro in fechados:  
            continue  
        fechados[atual.tabuleiro] = True  
        expandidos += 1  
        if limite_expansoes is not None and expandidos >= limite_expansoes:  
            return {  
                "encontrado": False,  
                "motivo": f"limite_expansoes={limite_expansoes} atingido",  
                "tamanho_fechados": len(fechados),  
                "tamanho_fronteira": len(fronteira),  
                "expandidos": expandidos,  
                "algoritmo": algoritmo,  
                "heuristica": heuristica if algoritmo == "astar" else None  
            }  
        for filho in atual.expandir():  
            g = filho.custo  
            if (filho.tabuleiro not in custo_ate) or (g < custo_ate[filho.tabuleiro]):  
                custo_ate[filho.tabuleiro] = g  
                f = g + hfun(filho.tabuleiro)  
                heapq.heappush(fronteira, (f, contador, filho))  
                contador += 1  
\end{minted}  

\section{Reconstrução do Caminho}  
Após encontrar o objetivo, o caminho-solução é reconstruído:  

\begin{minted}[frame=lines, fontsize=\footnotesize, linenos]{python}  
def reconstruir_caminho(no):  
    """Reconstrói o caminho da solução a partir do nó final."""  
    caminho = []  
    while no:  
        caminho.append(no.tabuleiro)  
        no = no.pai  
    return list(reversed(caminho))  
\end{minted}  

\section{Experimentos e Resultados}  
Para avaliar o desempenho dos algoritmos, foram geradas instâncias aleatórias solucionáveis do 8-puzzle. Para cada instância, executou-se UCS e $A^*$ com ambas as heurísticas. As principais métricas coletadas incluem número de nós expandidos, comprimento da solução e tamanho da fronteira.  

\subsection{Exemplo de Execução}  
Abaixo, apresenta-se um exemplo de execução com uma instância gerada aleatoriamente (embaralhamento de 30 movimentos, semente 39):  

\begin{verbatim}  
Tabuleiro inicial:  
[1, 2, 3]  
[7, 4, 6]  
[9, 5, 8]  
Solucionável? True  

== UCS ==  
{'encontrado': True, 'movimentos': 4, 'custo': 4, 'tamanho_fechados': 20,  
 'tamanho_fronteira': 17, 'expandidos': 20, 'algoritmo': 'ucs', 'heuristica': None}  

== A* (Manhattan) ==  
{'encontrado': True, 'movimentos': 4, 'custo': 4, 'tamanho_fechados': 4,  
 'tamanho_fronteira': 5, 'expandidos': 4, 'algoritmo': 'astar', 'heuristica': 'manhattan'}  

Primeiros 5 passos (A*):  
Passo 0:  
[1, 2, 3]  
[7, 4, 6]  
[9, 5, 8]  
Passo 1:  
[1, 2, 3]  
[9, 4, 6]  
[7, 5, 8]  
Passo 2:  
[1, 2, 3]  
[4, 9, 6]  
[7, 5, 8]  
Passo 3:  
[1, 2, 3]  
[4, 5, 6]  
[7, 9, 8]  
Passo 4:  
[1, 2, 3]  
[4, 5, 6]  
[7, 8, 9]  
\end{verbatim}  

% ---------------------------------------------------------
